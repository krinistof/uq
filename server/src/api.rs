use connectrpc_axum::{ConnectError, ConnectRequest, ConnectResponse};
use ed25519_dalek::{Verifier, VerifyingKey, Signature};
use sha2::{Sha256, Digest};
use crate::{
    db::{self, Db},
    uq_proto::{PushRequest, PushResponse, PullRequest, PullResponse, LogRequest, LogResponse, Event},
};

// We need to implement the trait generated by connectrpc.
// However, connectrpc-axum usually generates a struct that takes a closure or a trait.
// Let's use the trait approach if generated, otherwise the simple function approach.
// `dt` used the Builder approach. I'll stick to that.

#[derive(Clone)]
pub struct UqServiceHandler {
    db: Db,
}

impl UqServiceHandler {
    pub fn new(db: Db) -> Self {
        Self { db }
    }

    pub async fn push(
        &self,
        req: ConnectRequest<PushRequest>,
    ) -> Result<ConnectResponse<PushResponse>, ConnectError> {
        let mut accepted_count = 0;
        let events = req.0.events;
        
        // Sort by timestamp? Or just process.
        
        for mut event in events {
            // 1. Verify Signature
            if !self.verify_signature(&event) {
                // Determine policy: invalid signature -> reject whole batch? or just skip?
                // For security, skipping is fine, but maybe warn.
                // We'll skip for now.
                tracing::warn!("Invalid signature for event");
                continue;
            }

            // 2. Set Timestamp (Server time)
            event.server_timestamp_ms = chrono::Utc::now().timestamp_millis();

            // 3. Insert
            if let Err(e) = db::insert_event(&self.db, &event).await {
                tracing::error!("DB Error: {}", e);
                return Err(ConnectError::new_internal("Database error"));
            }
            accepted_count += 1;
        }

        Ok(ConnectResponse::new(PushResponse { accepted_count }))
    }

    pub async fn pull(
        &self,
        req: ConnectRequest<PullRequest>,
    ) -> Result<ConnectResponse<PullResponse>, ConnectError> {
        let since = req.0.since_timestamp_ms;
        
        let events = db::get_events_since(&self.db, since)
            .await
            .map_err(|e| {
                tracing::error!("DB Error: {}", e);
                ConnectError::new_internal("Database error")
            })?;

        let server_timestamp_ms = chrono::Utc::now().timestamp_millis();

        Ok(ConnectResponse::new(PullResponse {
            events,
            server_timestamp_ms,
        }))
    }

    pub async fn log(
        &self,
        req: ConnectRequest<LogRequest>,
    ) -> Result<ConnectResponse<LogResponse>, ConnectError> {
        tracing::info!("Client Log: {}", req.0.message);
        Ok(ConnectResponse::new(LogResponse {}))
    }

    fn verify_signature(&self, event: &Event) -> bool {
        if event.author_pk.len() != 32 || event.signature.len() != 64 {
            return false;
        }

        let Ok(vk) = VerifyingKey::from_bytes(event.author_pk.as_slice().try_into().unwrap()) else {
            return false;
        };
        
        let sig = Signature::from_bytes(event.signature.as_slice().try_into().unwrap());

        // Construct message: sha256(payload) + topic_pk
        let mut hasher = Sha256::new();
        hasher.update(&event.payload);
        let payload_hash = hasher.finalize();
        
        let mut msg = Vec::with_capacity(32 + event.topic_pk.len());
        msg.extend_from_slice(&payload_hash);
        msg.extend_from_slice(&event.topic_pk);

        vk.verify(&msg, &sig).is_ok()
    }
}
